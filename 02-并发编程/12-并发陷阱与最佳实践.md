# 12-并发陷阱与最佳实践

[← 返回本章目录](./README.md) | [← 返回总目录](../README.md)

---

## 📋 目录

- [核心概念](#核心概念)
- [常见陷阱](#常见陷阱)
- [数据竞争](#数据竞争)
- [Goroutine泄漏](#goroutine泄漏)
- [死锁问题](#死锁问题)
- [性能问题](#性能问题)
- [最佳实践](#最佳实践)
- [调试工具](#调试工具)
- [面试题](#面试题)
- [参考资料](#参考资料)

---

## 核心概念

并发编程虽然强大，但也容易出现各种陷阱和问题。了解这些常见陷阱并掌握最佳实践，是编写高质量并发代码的关键。

```
常见并发陷阱：
1. 数据竞争（Data Race）
2. Goroutine 泄漏
3. 死锁（Deadlock）
4. 活锁（Livelock）
5. 循环变量捕获
6. Channel 误用
7. 锁的误用
8. 性能问题
```

---

## 常见陷阱

### 1. 循环变量捕获

```go
// ❌ 错误：闭包捕获循环变量
func bad() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(i) // 可能输出 5, 5, 5, 5, 5
		}()
	}
	wg.Wait()
}

// ✅ 方案 1：传递参数
func good1() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			fmt.Println(n) // 输出 0, 1, 2, 3, 4
		}(i)
	}
	wg.Wait()
}

// ✅ 方案 2：创建局部变量
func good2() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		i := i // 创建局部变量
		go func() {
			defer wg.Done()
			fmt.Println(i) // 输出 0, 1, 2, 3, 4
		}()
	}
	wg.Wait()
}
```

### 2. WaitGroup 误用

```go
// ❌ 错误：在 goroutine 内部调用 Add
func bad() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		go func() {
			wg.Add(1) // 可能在 Wait() 之后执行
			defer wg.Done()
			// 工作
		}()
	}
	wg.Wait() // 可能提前返回
}

// ✅ 正确：在启动 goroutine 前调用 Add
func good() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			// 工作
		}()
	}
	wg.Wait()
}
```

### 3. Channel 关闭误用

```go
// ❌ 错误：多次关闭 channel
func bad() {
	ch := make(chan int)
	close(ch)
	close(ch) // panic: close of closed channel
}

// ❌ 错误：向已关闭的 channel 发送
func bad2() {
	ch := make(chan int)
	close(ch)
	ch <- 1 // panic: send on closed channel
}

// ✅ 正确：使用 sync.Once 确保只关闭一次
func good() {
	ch := make(chan int)
	var once sync.Once
	
	closeChannel := func() {
		once.Do(func() {
			close(ch)
		})
	}
	
	// 可以多次调用，但只会关闭一次
	closeChannel()
	closeChannel()
}

// ✅ 正确：使用 done channel 通知关闭
func good2() {
	ch := make(chan int)
	done := make(chan struct{})
	
	go func() {
		defer close(ch)
		for {
			select {
			case <-done:
				return
			case ch <- 1:
			}
		}
	}()
	
	// 通知关闭
	close(done)
}
```

### 4. 锁的误用

```go
// ❌ 错误：忘记解锁
func bad() {
	var mu sync.Mutex
	mu.Lock()
	// 忘记 Unlock，导致死锁
}

// ❌ 错误：重复加锁
func bad2() {
	var mu sync.Mutex
	mu.Lock()
	mu.Lock() // 死锁
	mu.Unlock()
	mu.Unlock()
}

// ✅ 正确：使用 defer 确保解锁
func good() {
	var mu sync.Mutex
	mu.Lock()
	defer mu.Unlock()
	// 工作
}

// ❌ 错误：复制锁
func bad3() {
	var mu sync.Mutex
	mu.Lock()
	mu2 := mu // 复制了锁
	mu2.Unlock() // 不会解锁原来的 mu
}

// ✅ 正确：使用指针传递锁
func good3(mu *sync.Mutex) {
	mu.Lock()
	defer mu.Unlock()
	// 工作
}
```

---

## 数据竞争

### 1. 什么是数据竞争？

```go
// ❌ 数据竞争示例
package main

import (
	"fmt"
	"sync"
)

func main() {
	var count int
	var wg sync.WaitGroup
	
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			count++ // 数据竞争
		}()
	}
	
	wg.Wait()
	fmt.Println(count) // 结果不确定
}
```

### 2. 检测数据竞争

```bash
# 使用 -race 标志
go run -race main.go
go test -race
go build -race

# 输出示例：
# WARNING: DATA RACE
# Write at 0x00c000018090 by goroutine 7:
#   main.main.func1()
#       /path/to/main.go:15 +0x3e
```

### 3. 解决数据竞争

```go
// ✅ 方案 1：使用互斥锁
func solution1() {
	var (
		count int
		mu    sync.Mutex
		wg    sync.WaitGroup
	)
	
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			mu.Lock()
			count++
			mu.Unlock()
		}()
	}
	
	wg.Wait()
	fmt.Println(count) // 1000
}

// ✅ 方案 2：使用原子操作
func solution2() {
	var (
		count int64
		wg    sync.WaitGroup
	)
	
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			atomic.AddInt64(&count, 1)
		}()
	}
	
	wg.Wait()
	fmt.Println(count) // 1000
}

// ✅ 方案 3：使用 channel
func solution3() {
	countChan := make(chan int)
	done := make(chan int)
	
	// 计数器 goroutine
	go func() {
		count := 0
		for range countChan {
			count++
		}
		done <- count
	}()
	
	// 发送计数请求
	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			countChan <- 1
		}()
	}
	
	wg.Wait()
	close(countChan)
	fmt.Println(<-done) // 1000
}
```

---

## Goroutine泄漏

### 1. Channel 阻塞导致泄漏

```go
// ❌ 错误：goroutine 永远阻塞
func leak1() {
	ch := make(chan int)
	go func() {
		val := <-ch // 永远阻塞
		fmt.Println(val)
	}()
	// ch 没有发送数据
}

// ✅ 正确：使用带缓冲的 channel
func fix1() {
	ch := make(chan int, 1)
	go func() {
		select {
		case val := <-ch:
			fmt.Println(val)
		case <-time.After(time.Second):
			fmt.Println("超时")
		}
	}()
}

// ✅ 正确：使用 context
func fix2(ctx context.Context) {
	ch := make(chan int)
	go func() {
		select {
		case val := <-ch:
			fmt.Println(val)
		case <-ctx.Done():
			return
		}
	}()
}
```

### 2. 无限循环导致泄漏

```go
// ❌ 错误：无法退出的循环
func leak2() {
	go func() {
		for {
			// 无退出条件
			time.Sleep(time.Second)
		}
	}()
}

// ✅ 正确：使用 done channel
func fix3() {
	done := make(chan struct{})
	
	go func() {
		for {
			select {
			case <-done:
				return
			default:
				time.Sleep(time.Second)
			}
		}
	}()
	
	// 通知退出
	close(done)
}

// ✅ 正确：使用 context
func fix4(ctx context.Context) {
	go func() {
		ticker := time.NewTicker(time.Second)
		defer ticker.Stop()
		
		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				// 工作
			}
		}
	}()
}
```

### 3. 检测 Goroutine 泄漏

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	// 记录初始 goroutine 数量
	before := runtime.NumGoroutine()
	fmt.Println("初始 goroutines:", before)
	
	// 执行可能泄漏的代码
	potentialLeak()
	
	// 等待一段时间
	time.Sleep(2 * time.Second)
	
	// 检查 goroutine 数量
	after := runtime.NumGoroutine()
	fmt.Println("之后 goroutines:", after)
	
	if after > before {
		fmt.Printf("警告：可能存在 goroutine 泄漏！增加了 %d 个\n", after-before)
	}
}

func potentialLeak() {
	ch := make(chan int)
	go func() {
		<-ch // 永远阻塞
	}()
}
```

---

## 死锁问题

### 1. 循环等待导致死锁

```go
// ❌ 错误：循环等待
func deadlock1() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	
	go func() {
		ch1 <- 1
		<-ch2
	}()
	
	go func() {
		ch2 <- 2
		<-ch1
	}()
	
	time.Sleep(time.Second)
	// fatal error: all goroutines are asleep - deadlock!
}

// ✅ 正确：使用带缓冲的 channel
func fix5() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	
	go func() {
		ch1 <- 1
		<-ch2
	}()
	
	go func() {
		ch2 <- 2
		<-ch1
	}()
	
	time.Sleep(time.Second)
}

// ✅ 正确：使用 select
func fix6() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	
	go func() {
		select {
		case ch1 <- 1:
		case <-time.After(time.Second):
			return
		}
		<-ch2
	}()
	
	go func() {
		select {
		case ch2 <- 2:
		case <-time.After(time.Second):
			return
		}
		<-ch1
	}()
	
	time.Sleep(2 * time.Second)
}
```

### 2. 锁顺序不一致导致死锁

```go
// ❌ 错误：锁顺序不一致
func deadlock2() {
	var mu1, mu2 sync.Mutex
	
	go func() {
		mu1.Lock()
		time.Sleep(time.Millisecond)
		mu2.Lock()
		mu2.Unlock()
		mu1.Unlock()
	}()
	
	go func() {
		mu2.Lock()
		time.Sleep(time.Millisecond)
		mu1.Lock()
		mu1.Unlock()
		mu2.Unlock()
	}()
	
	time.Sleep(time.Second)
}

// ✅ 正确：保持一致的锁顺序
func fix7() {
	var mu1, mu2 sync.Mutex
	
	lockInOrder := func() {
		mu1.Lock()
		defer mu1.Unlock()
		mu2.Lock()
		defer mu2.Unlock()
		// 工作
	}
	
	go lockInOrder()
	go lockInOrder()
	
	time.Sleep(time.Second)
}
```

### 3. 检测死锁

```go
// Go 运行时会自动检测死锁
// fatal error: all goroutines are asleep - deadlock!

// 使用超时机制避免死锁
func withTimeout() {
	ch := make(chan int)
	
	select {
	case val := <-ch:
		fmt.Println(val)
	case <-time.After(time.Second):
		fmt.Println("超时，避免死锁")
	}
}
```

---

## 性能问题

### 1. 过多的 Goroutine

```go
// ❌ 不推荐：创建过多 goroutine
func tooManyGoroutines() {
	for i := 0; i < 1000000; i++ {
		go func() {
			time.Sleep(time.Second)
		}()
	}
}

// ✅ 推荐：使用 worker pool
func workerPool() {
	const numWorkers = 100
	jobs := make(chan int, 1000)
	
	var wg sync.WaitGroup
	for w := 0; w < numWorkers; w++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for job := range jobs {
				// 处理任务
				_ = job
			}
		}()
	}
	
	for i := 0; i < 1000000; i++ {
		jobs <- i
	}
	close(jobs)
	wg.Wait()
}
```

### 2. 锁竞争

```go
// ❌ 性能差：频繁加锁
func badPerformance() {
	var (
		count int
		mu    sync.Mutex
	)
	
	for i := 0; i < 1000; i++ {
		mu.Lock()
		count++
		mu.Unlock()
	}
}

// ✅ 性能好：批量操作
func goodPerformance() {
	var (
		count int
		mu    sync.Mutex
	)
	
	mu.Lock()
	for i := 0; i < 1000; i++ {
		count++
	}
	mu.Unlock()
}

// ✅ 更好：使用原子操作
func betterPerformance() {
	var count int64
	
	for i := 0; i < 1000; i++ {
		atomic.AddInt64(&count, 1)
	}
}
```

### 3. Channel 性能

```go
// ❌ 性能差：无缓冲 channel
func unbuffered() {
	ch := make(chan int)
	
	go func() {
		for i := 0; i < 1000; i++ {
			ch <- i // 每次都阻塞
		}
		close(ch)
	}()
	
	for range ch {
	}
}

// ✅ 性能好：带缓冲 channel
func buffered() {
	ch := make(chan int, 100)
	
	go func() {
		for i := 0; i < 1000; i++ {
			ch <- i // 减少阻塞
		}
		close(ch)
	}()
	
	for range ch {
	}
}
```

---

## 最佳实践

### 1. 使用 Context 控制生命周期

```go
func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		default:
			// 工作
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	go worker(ctx)
	
	// 等待完成或超时
	<-ctx.Done()
}
```

### 2. 使用 errgroup 处理错误

```go
import "golang.org/x/sync/errgroup"

func processWithErrGroup(ctx context.Context) error {
	g, ctx := errgroup.WithContext(ctx)
	
	for i := 0; i < 10; i++ {
		i := i
		g.Go(func() error {
			// 处理任务
			if i%2 == 0 {
				return fmt.Errorf("任务 %d 失败", i)
			}
			return nil
		})
	}
	
	// 等待所有任务完成，返回第一个错误
	return g.Wait()
}
```

### 3. 使用 sync.Pool 复用对象

```go
var bufferPool = sync.Pool{
	New: func() interface{} {
		return new(bytes.Buffer)
	},
}

func process() {
	buf := bufferPool.Get().(*bytes.Buffer)
	defer bufferPool.Put(buf)
	
	buf.Reset()
	// 使用 buf
}
```

### 4. 合理使用并发原语

```go
// 选择合适的并发原语：
// - 简单计数：atomic
// - 保护临界区：Mutex
// - 读多写少：RWMutex
// - 只执行一次：Once
// - 等待完成：WaitGroup
// - 通信：Channel
// - 取消/超时：Context
```

### 5. 避免过早优化

```go
// 1. 先写正确的代码
// 2. 使用 benchmark 测试性能
// 3. 使用 pprof 找到瓶颈
// 4. 针对性优化
// 5. 再次测试验证
```

---

## 调试工具

### 1. Race Detector

```bash
# 检测数据竞争
go run -race main.go
go test -race ./...
go build -race
```

### 2. pprof

```go
import (
	"net/http"
	_ "net/http/pprof"
)

func main() {
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()
	
	// 访问 http://localhost:6060/debug/pprof/
	// - goroutine: 查看所有 goroutine
	// - heap: 查看堆内存
	// - profile: CPU profile
}
```

### 3. trace

```go
import (
	"os"
	"runtime/trace"
)

func main() {
	f, _ := os.Create("trace.out")
	defer f.Close()
	
	trace.Start(f)
	defer trace.Stop()
	
	// 你的代码
}

// 分析：go tool trace trace.out
```

### 4. 监控 Goroutine 数量

```go
import (
	"runtime"
	"time"
)

func monitorGoroutines() {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
	}
}
```

---

## 面试题

### 1. 如何检测和避免数据竞争？

**答案：**

**检测：**
- 使用 `go run -race` 或 `go test -race`
- 使用静态分析工具

**避免：**
- 使用互斥锁保护共享数据
- 使用原子操作
- 使用 channel 通信
- 避免共享内存

### 2. 如何检测 Goroutine 泄漏？

**答案：**

1. 监控 `runtime.NumGoroutine()`
2. 使用 pprof 查看 goroutine 堆栈
3. 定期检查 goroutine 数量变化
4. 使用 goleak 库自动检测

### 3. 什么情况下会发生死锁？

**答案：**

死锁的四个必要条件：
1. **互斥**：资源不能被共享
2. **持有并等待**：持有资源的同时等待其他资源
3. **不可抢占**：资源不能被强制释放
4. **循环等待**：存在资源的循环等待链

**避免死锁：**
- 保持一致的锁顺序
- 使用超时机制
- 避免嵌套锁
- 使用 trylock

### 4. Channel 和 Mutex 如何选择？

**答案：**

| 场景 | 选择 |
|------|------|
| 传递数据所有权 | Channel |
| 保护共享状态 | Mutex |
| 协调多个 goroutine | Channel |
| 简单的计数器 | Atomic |
| 读多写少 | RWMutex |

**原则：** 通过通信共享内存，而不是通过共享内存通信

### 5. 如何优化并发性能？

**答案：**

1. **减少锁竞争**：缩小临界区、使用读写锁
2. **使用原子操作**：替代简单的锁操作
3. **使用 sync.Pool**：复用对象
4. **限制 Goroutine 数量**：使用 worker pool
5. **使用带缓冲的 Channel**：减少阻塞
6. **避免过早优化**：先测量再优化

---

## 参考资料

- [x] [Go Race Detector](https://go.dev/doc/articles/race_detector)
- [x] [Effective Go - Concurrency](https://go.dev/doc/effective_go#concurrency)
- [x] [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [x] [Common Mistakes in Go](https://github.com/golang/go/wiki/CommonMistakes)
- [x] [goleak - Goroutine Leak Detector](https://github.com/uber-go/goleak)

---

**上一节：** [11-GMP调度模型](./11-GMP调度模型.md)  
**返回目录：** [02-并发编程](./README.md)
