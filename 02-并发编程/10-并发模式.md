# 10-å¹¶å‘æ¨¡å¼

[â† è¿”å›æœ¬ç« ç›®å½•](./README.md) | [â† è¿”å›æ€»ç›®å½•](../README.md)

---

## ğŸ“‹ ç›®å½•

- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [åŸºç¡€æ¨¡å¼](#åŸºç¡€æ¨¡å¼)
- [é«˜çº§æ¨¡å¼](#é«˜çº§æ¨¡å¼)
- [å®æˆ˜æ¨¡å¼](#å®æˆ˜æ¨¡å¼)
- [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [é¢è¯•é¢˜](#é¢è¯•é¢˜)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

---

## æ ¸å¿ƒæ¦‚å¿µ

å¹¶å‘æ¨¡å¼æ˜¯è§£å†³å¹¶å‘ç¼–ç¨‹ä¸­å¸¸è§é—®é¢˜çš„å¯å¤ç”¨è§£å†³æ–¹æ¡ˆã€‚Go è¯­è¨€é€šè¿‡ goroutine å’Œ channel æä¾›äº†å¼ºå¤§çš„å¹¶å‘åŸè¯­ï¼ŒåŸºäºè¿™äº›åŸè¯­å¯ä»¥å®ç°å„ç§å¹¶å‘æ¨¡å¼ã€‚

```
å¸¸è§å¹¶å‘æ¨¡å¼ï¼š
1. Worker Poolï¼ˆå·¥ä½œæ± ï¼‰
2. Pipelineï¼ˆç®¡é“ï¼‰
3. Fan-Out/Fan-Inï¼ˆæ‰‡å‡º/æ‰‡å…¥ï¼‰
4. Or-Done Channelï¼ˆå–æ¶ˆæ¨¡å¼ï¼‰
5. Tee Channelï¼ˆåˆ†æµæ¨¡å¼ï¼‰
6. Bridge Channelï¼ˆæ¡¥æ¥æ¨¡å¼ï¼‰
7. Bounded Parallelismï¼ˆé™åˆ¶å¹¶å‘ï¼‰
8. Error Handlingï¼ˆé”™è¯¯å¤„ç†ï¼‰
```

---

## åŸºç¡€æ¨¡å¼

### 1. Worker Poolï¼ˆå·¥ä½œæ± ï¼‰

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// Job ä»»åŠ¡
type Job struct {
	ID   int
	Data string
}

// Result ç»“æœ
type Result struct {
	Job   Job
	Value string
}

// Worker å·¥ä½œè€…
func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
	defer wg.Done()
	for job := range jobs {
		fmt.Printf("Worker %d å¤„ç†ä»»åŠ¡ %d\n", id, job.ID)
		time.Sleep(time.Second) // æ¨¡æ‹Ÿå¤„ç†
		results <- Result{
			Job:   job,
			Value: fmt.Sprintf("ç»“æœ-%d", job.ID),
		}
	}
}

func main() {
	const numWorkers = 3
	const numJobs = 10

	jobs := make(chan Job, numJobs)
	results := make(chan Result, numJobs)

	// å¯åŠ¨ workers
	var wg sync.WaitGroup
	for i := 1; i <= numWorkers; i++ {
		wg.Add(1)
		go worker(i, jobs, results, &wg)
	}

	// å‘é€ä»»åŠ¡
	go func() {
		for i := 1; i <= numJobs; i++ {
			jobs <- Job{ID: i, Data: fmt.Sprintf("æ•°æ®-%d", i)}
		}
		close(jobs)
	}()

	// ç­‰å¾…å®Œæˆå¹¶å…³é—­ç»“æœ channel
	go func() {
		wg.Wait()
		close(results)
	}()

	// æ”¶é›†ç»“æœ
	for result := range results {
		fmt.Printf("æ”¶åˆ°ç»“æœ: %s\n", result.Value)
	}
}
```

### 2. Pipelineï¼ˆç®¡é“ï¼‰

```go
package main

import "fmt"

// é˜¶æ®µ 1: ç”Ÿæˆæ•°å­—
func generate(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for _, n := range nums {
			out <- n
		}
	}()
	return out
}

// é˜¶æ®µ 2: å¹³æ–¹
func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for n := range in {
			out <- n * n
		}
	}()
	return out
}

// é˜¶æ®µ 3: è¿‡æ»¤å¶æ•°
func filterEven(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for n := range in {
			if n%2 == 0 {
				out <- n
			}
		}
	}()
	return out
}

func main() {
	// æ„å»ºç®¡é“
	nums := generate(1, 2, 3, 4, 5)
	squared := square(nums)
	filtered := filterEven(squared)

	// æ¶ˆè´¹ç»“æœ
	for n := range filtered {
		fmt.Println(n)
	}
}
```

### 3. Fan-Out/Fan-Inï¼ˆæ‰‡å‡º/æ‰‡å…¥ï¼‰

```go
package main

import (
	"fmt"
	"sync"
)

// ç”Ÿæˆæ•°å­—
func generate(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for _, n := range nums {
			out <- n
		}
	}()
	return out
}

// å¹³æ–¹ï¼ˆFan-Outï¼šå¤šä¸ª goroutine å¤„ç†åŒä¸€ä¸ª channelï¼‰
func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for n := range in {
			out <- n * n
		}
	}()
	return out
}

// Fan-Inï¼šåˆå¹¶å¤šä¸ª channel
func merge(channels ...<-chan int) <-chan int {
	out := make(chan int)
	var wg sync.WaitGroup

	// ä¸ºæ¯ä¸ªè¾“å…¥ channel å¯åŠ¨ä¸€ä¸ª goroutine
	for _, ch := range channels {
		wg.Add(1)
		go func(c <-chan int) {
			defer wg.Done()
			for n := range c {
				out <- n
			}
		}(ch)
	}

	// ç­‰å¾…æ‰€æœ‰ goroutine å®Œæˆåå…³é—­è¾“å‡º channel
	go func() {
		wg.Wait()
		close(out)
	}()

	return out
}

func main() {
	nums := generate(1, 2, 3, 4, 5, 6, 7, 8)

	// Fan-Outï¼šå¯åŠ¨å¤šä¸ª worker
	c1 := square(nums)
	c2 := square(nums)
	c3 := square(nums)

	// Fan-Inï¼šåˆå¹¶ç»“æœ
	for n := range merge(c1, c2, c3) {
		fmt.Println(n)
	}
}
```

### 4. Or-Done Channelï¼ˆå–æ¶ˆæ¨¡å¼ï¼‰

```go
package main

import (
	"fmt"
	"time"
)

// orDone åœ¨ done æˆ– channel å…³é—­æ—¶è¿”å›
func orDone(done <-chan struct{}, c <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for {
			select {
			case <-done:
				return
			case v, ok := <-c:
				if !ok {
					return
				}
				select {
				case out <- v:
				case <-done:
					return
				}
			}
		}
	}()
	return out
}

func main() {
	done := make(chan struct{})
	nums := make(chan int)

	// ç”Ÿæˆæ•°å­—
	go func() {
		defer close(nums)
		for i := 1; i <= 10; i++ {
			nums <- i
			time.Sleep(500 * time.Millisecond)
		}
	}()

	// 2 ç§’åå–æ¶ˆ
	go func() {
		time.Sleep(2 * time.Second)
		close(done)
	}()

	// æ¶ˆè´¹æ•°å­—
	for n := range orDone(done, nums) {
		fmt.Println(n)
	}
	fmt.Println("å®Œæˆ")
}
```

---

## é«˜çº§æ¨¡å¼

### 1. Tee Channelï¼ˆåˆ†æµæ¨¡å¼ï¼‰

```go
package main

import "fmt"

// tee å°†ä¸€ä¸ª channel åˆ†æµåˆ°ä¸¤ä¸ª channel
func tee(in <-chan int) (<-chan int, <-chan int) {
	out1 := make(chan int)
	out2 := make(chan int)

	go func() {
		defer close(out1)
		defer close(out2)
		for val := range in {
			// åŒæ—¶å‘é€åˆ°ä¸¤ä¸ª channel
			out1, out2 := out1, out2
			for i := 0; i < 2; i++ {
				select {
				case out1 <- val:
					out1 = nil
				case out2 <- val:
					out2 = nil
				}
			}
		}
	}()

	return out1, out2
}

func main() {
	nums := make(chan int)

	// ç”Ÿæˆæ•°å­—
	go func() {
		defer close(nums)
		for i := 1; i <= 5; i++ {
			nums <- i
		}
	}()

	// åˆ†æµ
	out1, out2 := tee(nums)

	// æ¶ˆè´¹
	go func() {
		for n := range out1 {
			fmt.Println("Out1:", n)
		}
	}()

	for n := range out2 {
		fmt.Println("Out2:", n)
	}
}
```

### 2. Bridge Channelï¼ˆæ¡¥æ¥æ¨¡å¼ï¼‰

```go
package main

import "fmt"

// bridge å°† channel çš„ channel æ¡¥æ¥æˆå•ä¸ª channel
func bridge(done <-chan struct{}, chanStream <-chan <-chan int) <-chan int {
	out := make(chan int)

	go func() {
		defer close(out)
		for {
			var stream <-chan int
			select {
			case <-done:
				return
			case maybeStream, ok := <-chanStream:
				if !ok {
					return
				}
				stream = maybeStream
			}

			for val := range stream {
				select {
				case <-done:
					return
				case out <- val:
				}
			}
		}
	}()

	return out
}

func main() {
	done := make(chan struct{})
	defer close(done)

	chanStream := make(chan (<-chan int))

	// ç”Ÿæˆå¤šä¸ª channel
	go func() {
		defer close(chanStream)
		for i := 0; i < 3; i++ {
			stream := make(chan int)
			chanStream <- stream
			go func(s chan int, start int) {
				defer close(s)
				for j := start; j < start+3; j++ {
					s <- j
				}
			}(stream, i*10)
		}
	}()

	// æ¡¥æ¥å¹¶æ¶ˆè´¹
	for val := range bridge(done, chanStream) {
		fmt.Println(val)
	}
}
```

### 3. Bounded Parallelismï¼ˆé™åˆ¶å¹¶å‘ï¼‰

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// æ–¹æ¡ˆ 1: ä½¿ç”¨å¸¦ç¼“å†²çš„ channel
func boundedParallelism1(tasks []int, maxConcurrent int) {
	sem := make(chan struct{}, maxConcurrent)
	var wg sync.WaitGroup

	for _, task := range tasks {
		wg.Add(1)
		go func(t int) {
			defer wg.Done()
			sem <- struct{}{}        // è·å–ä¿¡å·é‡
			defer func() { <-sem }() // é‡Šæ”¾ä¿¡å·é‡

			fmt.Printf("å¤„ç†ä»»åŠ¡ %d\n", t)
			time.Sleep(time.Second)
		}(task)
	}

	wg.Wait()
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ worker pool
func boundedParallelism2(tasks []int, maxConcurrent int) {
	taskChan := make(chan int, len(tasks))
	var wg sync.WaitGroup

	// å¯åŠ¨å›ºå®šæ•°é‡çš„ workers
	for i := 0; i < maxConcurrent; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for task := range taskChan {
				fmt.Printf("Worker %d å¤„ç†ä»»åŠ¡ %d\n", id, task)
				time.Sleep(time.Second)
			}
		}(i)
	}

	// å‘é€ä»»åŠ¡
	for _, task := range tasks {
		taskChan <- task
	}
	close(taskChan)

	wg.Wait()
}

func main() {
	tasks := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	fmt.Println("æ–¹æ¡ˆ 1:")
	boundedParallelism1(tasks, 3)

	fmt.Println("\næ–¹æ¡ˆ 2:")
	boundedParallelism2(tasks, 3)
}
```

### 4. Error Handlingï¼ˆé”™è¯¯å¤„ç†ï¼‰

```go
package main

import (
	"fmt"
	"sync"
)

// Result ç»“æœ
type Result struct {
	Value int
	Error error
}

// æ–¹æ¡ˆ 1: ä½¿ç”¨ channel ä¼ é€’é”™è¯¯
func processWithErrorChannel(tasks []int) <-chan Result {
	results := make(chan Result)

	go func() {
		defer close(results)
		var wg sync.WaitGroup

		for _, task := range tasks {
			wg.Add(1)
			go func(t int) {
				defer wg.Done()
				// æ¨¡æ‹Ÿå¤„ç†
				if t%2 == 0 {
					results <- Result{Value: t * t, Error: nil}
				} else {
					results <- Result{Value: 0, Error: fmt.Errorf("ä»»åŠ¡ %d å¤±è´¥", t)}
				}
			}(task)
		}

		wg.Wait()
	}()

	return results
}

// æ–¹æ¡ˆ 2: ä½¿ç”¨ errgroup
func processWithErrGroup(tasks []int) ([]int, error) {
	var (
		mu      sync.Mutex
		results []int
	)

	var wg sync.WaitGroup
	errChan := make(chan error, len(tasks))

	for _, task := range tasks {
		wg.Add(1)
		go func(t int) {
			defer wg.Done()
			// æ¨¡æ‹Ÿå¤„ç†
			if t%2 == 0 {
				mu.Lock()
				results = append(results, t*t)
				mu.Unlock()
			} else {
				errChan <- fmt.Errorf("ä»»åŠ¡ %d å¤±è´¥", t)
			}
		}(task)
	}

	wg.Wait()
	close(errChan)

	// æ”¶é›†é”™è¯¯
	for err := range errChan {
		return nil, err // è¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
	}

	return results, nil
}

func main() {
	tasks := []int{1, 2, 3, 4, 5}

	fmt.Println("æ–¹æ¡ˆ 1:")
	for result := range processWithErrorChannel(tasks) {
		if result.Error != nil {
			fmt.Printf("é”™è¯¯: %v\n", result.Error)
		} else {
			fmt.Printf("ç»“æœ: %d\n", result.Value)
		}
	}

	fmt.Println("\næ–¹æ¡ˆ 2:")
	results, err := processWithErrGroup(tasks)
	if err != nil {
		fmt.Printf("é”™è¯¯: %v\n", err)
	} else {
		fmt.Printf("ç»“æœ: %v\n", results)
	}
}
```

---

## å®æˆ˜æ¨¡å¼

### 1. è¶…æ—¶æ§åˆ¶

```go
package main

import (
	"fmt"
	"time"
)

func doWork() <-chan string {
	result := make(chan string)
	go func() {
		defer close(result)
		time.Sleep(2 * time.Second)
		result <- "å·¥ä½œå®Œæˆ"
	}()
	return result
}

func main() {
	timeout := time.After(1 * time.Second)

	select {
	case result := <-doWork():
		fmt.Println(result)
	case <-timeout:
		fmt.Println("è¶…æ—¶")
	}
}
```

### 2. å¿ƒè·³æ£€æµ‹

```go
package main

import (
	"fmt"
	"time"
)

func heartbeat(interval time.Duration) <-chan struct{} {
	heartbeat := make(chan struct{})
	go func() {
		ticker := time.NewTicker(interval)
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				heartbeat <- struct{}{}
			}
		}
	}()
	return heartbeat
}

func main() {
	done := time.After(5 * time.Second)
	hb := heartbeat(1 * time.Second)

	for {
		select {
		case <-done:
			fmt.Println("å®Œæˆ")
			return
		case <-hb:
			fmt.Println("å¿ƒè·³")
		}
	}
}
```

### 3. é€Ÿç‡é™åˆ¶

```go
package main

import (
	"fmt"
	"time"
)

func rateLimiter(rate time.Duration) <-chan time.Time {
	return time.Tick(rate)
}

func main() {
	limiter := rateLimiter(500 * time.Millisecond)

	for i := 1; i <= 5; i++ {
		<-limiter
		fmt.Printf("è¯·æ±‚ %d åœ¨ %v\n", i, time.Now())
	}
}
```

### 4. é‡è¯•æœºåˆ¶

```go
package main

import (
	"fmt"
	"time"
)

func retry(attempts int, sleep time.Duration, fn func() error) error {
	for i := 0; i < attempts; i++ {
		if err := fn(); err != nil {
			if i == attempts-1 {
				return err
			}
			fmt.Printf("å°è¯• %d å¤±è´¥ï¼Œ%v åé‡è¯•\n", i+1, sleep)
			time.Sleep(sleep)
			continue
		}
		return nil
	}
	return nil
}

func main() {
	count := 0
	err := retry(3, 1*time.Second, func() error {
		count++
		if count < 3 {
			return fmt.Errorf("å¤±è´¥")
		}
		return nil
	})

	if err != nil {
		fmt.Println("æœ€ç»ˆå¤±è´¥:", err)
	} else {
		fmt.Println("æˆåŠŸ")
	}
}
```

---

## ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹ 1: å¹¶å‘çˆ¬è™«

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// Page é¡µé¢
type Page struct {
	URL     string
	Content string
}

// Crawler çˆ¬è™«
type Crawler struct {
	maxWorkers int
	visited    map[string]bool
	mu         sync.Mutex
}

// NewCrawler åˆ›å»ºçˆ¬è™«
func NewCrawler(maxWorkers int) *Crawler {
	return &Crawler{
		maxWorkers: maxWorkers,
		visited:    make(map[string]bool),
	}
}

// Crawl çˆ¬å–
func (c *Crawler) Crawl(urls []string) []Page {
	urlChan := make(chan string, len(urls))
	pageChan := make(chan Page, len(urls))

	// å¯åŠ¨ workers
	var wg sync.WaitGroup
	for i := 0; i < c.maxWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for url := range urlChan {
				page := c.fetchPage(url)
				pageChan <- page
			}
		}()
	}

	// å‘é€ URLs
	go func() {
		for _, url := range urls {
			c.mu.Lock()
			if !c.visited[url] {
				c.visited[url] = true
				urlChan <- url
			}
			c.mu.Unlock()
		}
		close(urlChan)
	}()

	// ç­‰å¾…å®Œæˆ
	go func() {
		wg.Wait()
		close(pageChan)
	}()

	// æ”¶é›†ç»“æœ
	var pages []Page
	for page := range pageChan {
		pages = append(pages, page)
	}

	return pages
}

func (c *Crawler) fetchPage(url string) Page {
	fmt.Printf("çˆ¬å–: %s\n", url)
	time.Sleep(500 * time.Millisecond) // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
	return Page{
		URL:     url,
		Content: fmt.Sprintf("å†…å®¹-%s", url),
	}
}

func main() {
	urls := []string{
		"https://example.com/1",
		"https://example.com/2",
		"https://example.com/3",
		"https://example.com/4",
		"https://example.com/5",
	}

	crawler := NewCrawler(3)
	pages := crawler.Crawl(urls)

	for _, page := range pages {
		fmt.Printf("æ”¶åˆ°: %s\n", page.URL)
	}
}
```

### ç¤ºä¾‹ 2: å¹¶å‘ä¸‹è½½å™¨

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// Download ä¸‹è½½ä»»åŠ¡
type Download struct {
	URL      string
	Filename string
}

// Downloader ä¸‹è½½å™¨
type Downloader struct {
	maxConcurrent int
}

// NewDownloader åˆ›å»ºä¸‹è½½å™¨
func NewDownloader(maxConcurrent int) *Downloader {
	return &Downloader{maxConcurrent: maxConcurrent}
}

// Download ä¸‹è½½
func (d *Downloader) Download(downloads []Download) {
	sem := make(chan struct{}, d.maxConcurrent)
	var wg sync.WaitGroup

	for _, dl := range downloads {
		wg.Add(1)
		go func(download Download) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			d.downloadFile(download)
		}(dl)
	}

	wg.Wait()
}

func (d *Downloader) downloadFile(dl Download) {
	fmt.Printf("å¼€å§‹ä¸‹è½½: %s -> %s\n", dl.URL, dl.Filename)
	time.Sleep(time.Second) // æ¨¡æ‹Ÿä¸‹è½½
	fmt.Printf("å®Œæˆä¸‹è½½: %s\n", dl.Filename)
}

func main() {
	downloads := []Download{
		{URL: "https://example.com/file1.zip", Filename: "file1.zip"},
		{URL: "https://example.com/file2.zip", Filename: "file2.zip"},
		{URL: "https://example.com/file3.zip", Filename: "file3.zip"},
		{URL: "https://example.com/file4.zip", Filename: "file4.zip"},
		{URL: "https://example.com/file5.zip", Filename: "file5.zip"},
	}

	downloader := NewDownloader(3)
	downloader.Download(downloads)
}
```

---

## å¸¸è§é—®é¢˜

### 1. å¦‚ä½•é€‰æ‹©åˆé€‚çš„å¹¶å‘æ¨¡å¼ï¼Ÿ

| åœºæ™¯ | æ¨èæ¨¡å¼ |
|------|----------|
| å›ºå®šæ•°é‡çš„ä»»åŠ¡ | Worker Pool |
| æ•°æ®æµå¤„ç† | Pipeline |
| éœ€è¦é™åˆ¶å¹¶å‘æ•° | Bounded Parallelism |
| éœ€è¦å–æ¶ˆæ“ä½œ | Or-Done Channel |
| éœ€è¦åˆå¹¶ç»“æœ | Fan-In |

### 2. Worker Pool å’Œ Bounded Parallelism çš„åŒºåˆ«ï¼Ÿ

**Worker Poolï¼š**
- å›ºå®šæ•°é‡çš„ workers
- é€‚åˆé•¿æœŸè¿è¡Œçš„ä»»åŠ¡
- ä»»åŠ¡é€šè¿‡ channel åˆ†å‘

**Bounded Parallelismï¼š**
- é™åˆ¶å¹¶å‘æ•°é‡
- é€‚åˆçŸ­æœŸä»»åŠ¡
- ä½¿ç”¨ä¿¡å·é‡æ§åˆ¶

### 3. å¦‚ä½•å¤„ç†å¹¶å‘é”™è¯¯ï¼Ÿ

```go
// æ–¹æ¡ˆ 1: æ”¶é›†æ‰€æœ‰é”™è¯¯
errors := make(chan error, len(tasks))

// æ–¹æ¡ˆ 2: è¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
select {
case err := <-errChan:
	return err
}

// æ–¹æ¡ˆ 3: ä½¿ç”¨ errgroup
```

---

## é¢è¯•é¢˜

### 1. ä»€ä¹ˆæ˜¯ Fan-Out/Fan-In æ¨¡å¼ï¼Ÿ

**ç­”æ¡ˆï¼š**

**Fan-Outï¼š** å¤šä¸ª goroutine ä»åŒä¸€ä¸ª channel è¯»å–æ•°æ®å¹¶å¤„ç†

**Fan-Inï¼š** å¤šä¸ª channel çš„æ•°æ®åˆå¹¶åˆ°ä¸€ä¸ª channel

**é€‚ç”¨åœºæ™¯ï¼š** éœ€è¦å¹¶è¡Œå¤„ç†å¤§é‡æ•°æ®å¹¶åˆå¹¶ç»“æœ

### 2. å¦‚ä½•å®ç°ä¼˜é›…å…³é—­ï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
done := make(chan struct{})

// é€šçŸ¥å…³é—­
close(done)

// æ£€æŸ¥å…³é—­
select {
case <-done:
	return
case v := <-ch:
	// å¤„ç†
}
```

### 3. Pipeline æ¨¡å¼çš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ

**ç­”æ¡ˆï¼š**

1. **è§£è€¦**ï¼šæ¯ä¸ªé˜¶æ®µç‹¬ç«‹
2. **å¯ç»„åˆ**ï¼šå¯ä»¥çµæ´»ç»„åˆé˜¶æ®µ
3. **å¹¶å‘**ï¼šæ¯ä¸ªé˜¶æ®µå¯ä»¥å¹¶å‘æ‰§è¡Œ
4. **å¯æµ‹è¯•**ï¼šæ¯ä¸ªé˜¶æ®µå¯ä»¥å•ç‹¬æµ‹è¯•

---

## æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ context æ§åˆ¶ç”Ÿå‘½å‘¨æœŸ

```go
func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		default:
			// å·¥ä½œ
		}
	}
}
```

### 2. é¿å… goroutine æ³„æ¼

```go
// âœ… ç¡®ä¿ goroutine èƒ½å¤Ÿé€€å‡º
done := make(chan struct{})
defer close(done)
```

### 3. åˆç†è®¾ç½®å¹¶å‘æ•°

```go
// æ ¹æ® CPU æ ¸å¿ƒæ•°è®¾ç½®
maxWorkers := runtime.NumCPU()
```

### 4. ä½¿ç”¨å¸¦ç¼“å†²çš„ channel

```go
// é¿å…é˜»å¡
ch := make(chan int, 100)
```

---

## å‚è€ƒèµ„æ–™

- [x] [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [x] [Advanced Go Concurrency Patterns](https://go.dev/blog/io2013-talk-concurrency)
- [x] [Concurrency in Go (Book)](https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/)

---

**ä¸Šä¸€èŠ‚ï¼š** [09-åŸå­æ“ä½œAtomic](./09-åŸå­æ“ä½œAtomic.md)  
**ä¸‹ä¸€èŠ‚ï¼š** [11-GMPè°ƒåº¦æ¨¡å‹](./11-GMPè°ƒåº¦æ¨¡å‹.md)
