# 06-æ•°ç»„ä¸åˆ‡ç‰‡

[â† è¿”å›æœ¬ç« ç›®å½•](./README.md) | [â† è¿”å›æ€»ç›®å½•](../README.md)

---

## ğŸ“‹ ç›®å½•

- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [æ•°ç»„](#æ•°ç»„)
- [åˆ‡ç‰‡](#åˆ‡ç‰‡)
- [åˆ‡ç‰‡åº•å±‚å®ç°](#åˆ‡ç‰‡åº•å±‚å®ç°)
- [åˆ‡ç‰‡æ‰©å®¹æœºåˆ¶](#åˆ‡ç‰‡æ‰©å®¹æœºåˆ¶)
- [åˆ‡ç‰‡æ“ä½œ](#åˆ‡ç‰‡æ“ä½œ)
- [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [é¢è¯•é¢˜](#é¢è¯•é¢˜)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

---

## æ ¸å¿ƒæ¦‚å¿µ

### æ•°ç»„ vs åˆ‡ç‰‡

```
æ•°ç»„ï¼ˆArrayï¼‰:
- å›ºå®šé•¿åº¦
- å€¼ç±»å‹
- é•¿åº¦æ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†
- æ€§èƒ½æ›´å¥½ï¼ˆæ ˆåˆ†é…ï¼‰

åˆ‡ç‰‡ï¼ˆSliceï¼‰:
- åŠ¨æ€é•¿åº¦
- å¼•ç”¨ç±»å‹
- çµæ´»æ–¹ä¾¿
- åº•å±‚åŸºäºæ•°ç»„
```

### å…³é”®ç‰¹æ€§

- **æ•°ç»„**ï¼š`[n]T` è¡¨ç¤ºå›ºå®šé•¿åº¦ä¸º n çš„æ•°ç»„
- **åˆ‡ç‰‡**ï¼š`[]T` è¡¨ç¤ºåŠ¨æ€æ•°ç»„
- **åˆ‡ç‰‡ä¸‰è¦ç´ **ï¼šæŒ‡é’ˆã€é•¿åº¦ã€å®¹é‡

---

## æ•°ç»„

### 1. æ•°ç»„å£°æ˜

```go
package main

import "fmt"

func main() {
    // æ–¹å¼ 1: å£°æ˜åèµ‹å€¼
    var arr1 [5]int
    arr1[0] = 1
    arr1[1] = 2
    fmt.Println(arr1)  // [1 2 0 0 0]
    
    // æ–¹å¼ 2: å£°æ˜æ—¶åˆå§‹åŒ–
    arr2 := [5]int{1, 2, 3, 4, 5}
    fmt.Println(arr2)  // [1 2 3 4 5]
    
    // æ–¹å¼ 3: è‡ªåŠ¨æ¨å¯¼é•¿åº¦
    arr3 := [...]int{1, 2, 3}
    fmt.Println(arr3)  // [1 2 3]
    
    // æ–¹å¼ 4: æŒ‡å®šç´¢å¼•åˆå§‹åŒ–
    arr4 := [5]int{1: 10, 3: 30}
    fmt.Println(arr4)  // [0 10 0 30 0]
}
```

### 2. æ•°ç»„æ“ä½œ

```go
package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    
    // è®¿é—®å…ƒç´ 
    fmt.Println("arr[0] =", arr[0])
    
    // ä¿®æ”¹å…ƒç´ 
    arr[0] = 10
    fmt.Println(arr)
    
    // è·å–é•¿åº¦
    fmt.Println("é•¿åº¦:", len(arr))
    
    // éå†æ•°ç»„
    for i := 0; i < len(arr); i++ {
        fmt.Printf("arr[%d] = %d\n", i, arr[i])
    }
    
    // for-range éå†
    for i, v := range arr {
        fmt.Printf("arr[%d] = %d\n", i, v)
    }
}
```

### 3. æ•°ç»„æ˜¯å€¼ç±»å‹

```go
package main

import "fmt"

func modifyArray(arr [3]int) {
    arr[0] = 100
    fmt.Println("å‡½æ•°å†…:", arr)
}

func main() {
    arr := [3]int{1, 2, 3}
    modifyArray(arr)
    fmt.Println("å‡½æ•°å¤–:", arr)  // [1 2 3] (æœªæ”¹å˜)
    
    // æ•°ç»„èµ‹å€¼æ˜¯å¤åˆ¶
    arr2 := arr
    arr2[0] = 100
    fmt.Println("arr:", arr)    // [1 2 3]
    fmt.Println("arr2:", arr2)  // [100 2 3]
}
```

### 4. æ•°ç»„æ¯”è¾ƒ

```go
package main

import "fmt"

func main() {
    arr1 := [3]int{1, 2, 3}
    arr2 := [3]int{1, 2, 3}
    arr3 := [3]int{1, 2, 4}
    
    // æ•°ç»„å¯ä»¥æ¯”è¾ƒï¼ˆå…ƒç´ ç±»å‹å¯æ¯”è¾ƒï¼‰
    fmt.Println("arr1 == arr2:", arr1 == arr2)  // true
    fmt.Println("arr1 == arr3:", arr1 == arr3)  // false
    
    // ä¸åŒé•¿åº¦çš„æ•°ç»„æ˜¯ä¸åŒç±»å‹ï¼Œä¸èƒ½æ¯”è¾ƒ
    // arr4 := [4]int{1, 2, 3, 4}
    // fmt.Println(arr1 == arr4)  // ç¼–è¯‘é”™è¯¯
}
```

### 5. å¤šç»´æ•°ç»„

```go
package main

import "fmt"

func main() {
    // äºŒç»´æ•°ç»„
    var matrix [3][4]int
    matrix[0][0] = 1
    fmt.Println(matrix)
    
    // åˆå§‹åŒ–äºŒç»´æ•°ç»„
    matrix2 := [3][4]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }
    
    // éå†äºŒç»´æ•°ç»„
    for i := 0; i < len(matrix2); i++ {
        for j := 0; j < len(matrix2[i]); j++ {
            fmt.Printf("%3d ", matrix2[i][j])
        }
        fmt.Println()
    }
}
```

---

## åˆ‡ç‰‡

### 1. åˆ‡ç‰‡å£°æ˜

```go
package main

import "fmt"

func main() {
    // æ–¹å¼ 1: å£°æ˜ nil åˆ‡ç‰‡
    var slice1 []int
    fmt.Printf("slice1: %v, len: %d, cap: %d, nil: %v\n", 
        slice1, len(slice1), cap(slice1), slice1 == nil)
    
    // æ–¹å¼ 2: ä½¿ç”¨å­—é¢é‡
    slice2 := []int{1, 2, 3, 4, 5}
    fmt.Printf("slice2: %v, len: %d, cap: %d\n", 
        slice2, len(slice2), cap(slice2))
    
    // æ–¹å¼ 3: ä½¿ç”¨ make
    slice3 := make([]int, 5)      // é•¿åº¦å’Œå®¹é‡éƒ½æ˜¯ 5
    slice4 := make([]int, 3, 10)  // é•¿åº¦ 3ï¼Œå®¹é‡ 10
    fmt.Printf("slice3: %v, len: %d, cap: %d\n", 
        slice3, len(slice3), cap(slice3))
    fmt.Printf("slice4: %v, len: %d, cap: %d\n", 
        slice4, len(slice4), cap(slice4))
    
    // æ–¹å¼ 4: ä»æ•°ç»„åˆ›å»º
    arr := [5]int{1, 2, 3, 4, 5}
    slice5 := arr[1:4]  // [2 3 4]
    fmt.Printf("slice5: %v, len: %d, cap: %d\n", 
        slice5, len(slice5), cap(slice5))
}
```

### 2. åˆ‡ç‰‡æˆªå–

```go
package main

import "fmt"

func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    
    // slice[low:high]
    fmt.Println(slice[2:5])   // [2 3 4]
    fmt.Println(slice[:5])    // [0 1 2 3 4]
    fmt.Println(slice[5:])    // [5 6 7 8 9]
    fmt.Println(slice[:])     // [0 1 2 3 4 5 6 7 8 9]
    
    // slice[low:high:max] (å®Œæ•´åˆ‡ç‰‡è¡¨è¾¾å¼)
    s := slice[2:5:7]
    fmt.Printf("s: %v, len: %d, cap: %d\n", s, len(s), cap(s))
    // s: [2 3 4], len: 3, cap: 5
}
```

### 3. åˆ‡ç‰‡è¿½åŠ 

```go
package main

import "fmt"

func main() {
    var slice []int
    fmt.Printf("slice: %v, len: %d, cap: %d\n", 
        slice, len(slice), cap(slice))
    
    // è¿½åŠ å•ä¸ªå…ƒç´ 
    slice = append(slice, 1)
    fmt.Printf("slice: %v, len: %d, cap: %d\n", 
        slice, len(slice), cap(slice))
    
    // è¿½åŠ å¤šä¸ªå…ƒç´ 
    slice = append(slice, 2, 3, 4)
    fmt.Printf("slice: %v, len: %d, cap: %d\n", 
        slice, len(slice), cap(slice))
    
    // è¿½åŠ åˆ‡ç‰‡
    slice2 := []int{5, 6, 7}
    slice = append(slice, slice2...)
    fmt.Printf("slice: %v, len: %d, cap: %d\n", 
        slice, len(slice), cap(slice))
}
```

### 4. åˆ‡ç‰‡å¤åˆ¶

```go
package main

import "fmt"

func main() {
    src := []int{1, 2, 3, 4, 5}
    
    // æ–¹å¼ 1: ä½¿ç”¨ copy
    dst := make([]int, len(src))
    n := copy(dst, src)
    fmt.Printf("å¤åˆ¶äº† %d ä¸ªå…ƒç´ \n", n)
    fmt.Println("dst:", dst)
    
    // ä¿®æ”¹ dst ä¸å½±å“ src
    dst[0] = 100
    fmt.Println("src:", src)  // [1 2 3 4 5]
    fmt.Println("dst:", dst)  // [100 2 3 4 5]
    
    // æ–¹å¼ 2: éƒ¨åˆ†å¤åˆ¶
    dst2 := make([]int, 3)
    copy(dst2, src)
    fmt.Println("dst2:", dst2)  // [1 2 3]
    
    // æ–¹å¼ 3: ä½¿ç”¨ append
    dst3 := append([]int{}, src...)
    fmt.Println("dst3:", dst3)
}
```

### 5. åˆ‡ç‰‡åˆ é™¤

```go
package main

import "fmt"

func main() {
    slice := []int{1, 2, 3, 4, 5}
    
    // åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
    slice = slice[1:]
    fmt.Println(slice)  // [2 3 4 5]
    
    // åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
    slice = slice[:len(slice)-1]
    fmt.Println(slice)  // [2 3 4]
    
    // åˆ é™¤ä¸­é—´å…ƒç´ ï¼ˆç´¢å¼• 1ï¼‰
    slice = []int{1, 2, 3, 4, 5}
    i := 1
    slice = append(slice[:i], slice[i+1:]...)
    fmt.Println(slice)  // [1 3 4 5]
}
```

---

## åˆ‡ç‰‡åº•å±‚å®ç°

### 1. åˆ‡ç‰‡ç»“æ„

```go
// åˆ‡ç‰‡çš„åº•å±‚ç»“æ„ï¼ˆruntime/slice.goï¼‰
type slice struct {
    array unsafe.Pointer  // æŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆ
    len   int             // åˆ‡ç‰‡é•¿åº¦
    cap   int             // åˆ‡ç‰‡å®¹é‡
}
```

### 2. åˆ‡ç‰‡å’Œæ•°ç»„çš„å…³ç³»

```go
package main

import "fmt"

func main() {
    // æ•°ç»„
    arr := [5]int{1, 2, 3, 4, 5}
    
    // ä»æ•°ç»„åˆ›å»ºåˆ‡ç‰‡
    slice := arr[1:4]
    fmt.Println("slice:", slice)  // [2 3 4]
    
    // ä¿®æ”¹åˆ‡ç‰‡ä¼šå½±å“åº•å±‚æ•°ç»„
    slice[0] = 100
    fmt.Println("arr:", arr)      // [1 100 3 4 5]
    fmt.Println("slice:", slice)  // [100 3 4]
    
    // ä¿®æ”¹æ•°ç»„ä¹Ÿä¼šå½±å“åˆ‡ç‰‡
    arr[2] = 200
    fmt.Println("arr:", arr)      // [1 100 200 4 5]
    fmt.Println("slice:", slice)  // [100 200 4]
}
```

### 3. åˆ‡ç‰‡å…±äº«åº•å±‚æ•°ç»„

```go
package main

import "fmt"

func main() {
    slice1 := []int{1, 2, 3, 4, 5}
    slice2 := slice1[1:3]
    slice3 := slice1[2:5]
    
    fmt.Println("slice1:", slice1)  // [1 2 3 4 5]
    fmt.Println("slice2:", slice2)  // [2 3]
    fmt.Println("slice3:", slice3)  // [3 4 5]
    
    // ä¿®æ”¹ slice2 ä¼šå½±å“ slice1 å’Œ slice3
    slice2[1] = 100
    fmt.Println("slice1:", slice1)  // [1 2 100 4 5]
    fmt.Println("slice2:", slice2)  // [2 100]
    fmt.Println("slice3:", slice3)  // [100 4 5]
}
```

### 4. nil åˆ‡ç‰‡ vs ç©ºåˆ‡ç‰‡

```go
package main

import "fmt"

func main() {
    // nil åˆ‡ç‰‡
    var slice1 []int
    fmt.Printf("slice1: %v, len: %d, cap: %d, nil: %v\n", 
        slice1, len(slice1), cap(slice1), slice1 == nil)
    
    // ç©ºåˆ‡ç‰‡
    slice2 := []int{}
    fmt.Printf("slice2: %v, len: %d, cap: %d, nil: %v\n", 
        slice2, len(slice2), cap(slice2), slice2 == nil)
    
    slice3 := make([]int, 0)
    fmt.Printf("slice3: %v, len: %d, cap: %d, nil: %v\n", 
        slice3, len(slice3), cap(slice3), slice3 == nil)
    
    // ä½¿ç”¨ä¸Šå‡ ä¹æ²¡æœ‰åŒºåˆ«
    fmt.Println("len(slice1):", len(slice1))
    fmt.Println("len(slice2):", len(slice2))
    
    // JSON åºåˆ—åŒ–æœ‰åŒºåˆ«
    // nil åˆ‡ç‰‡ -> null
    // ç©ºåˆ‡ç‰‡ -> []
}
```

---

## åˆ‡ç‰‡æ‰©å®¹æœºåˆ¶

### 1. æ‰©å®¹è§„åˆ™

```go
// Go 1.18+ çš„æ‰©å®¹ç­–ç•¥ï¼š
// 1. å¦‚æœæ–°å®¹é‡ > 2 * æ—§å®¹é‡ï¼Œåˆ™æ–°å®¹é‡ = æ–°å®¹é‡
// 2. å¦åˆ™ï¼š
//    - å¦‚æœæ—§å®¹é‡ < 256ï¼Œåˆ™æ–°å®¹é‡ = 2 * æ—§å®¹é‡
//    - å¦‚æœæ—§å®¹é‡ >= 256ï¼Œåˆ™æ–°å®¹é‡ = æ—§å®¹é‡ + (æ—§å®¹é‡ + 3*256) / 4
```

### 2. æ‰©å®¹ç¤ºä¾‹

```go
package main

import "fmt"

func main() {
    slice := make([]int, 0, 1)
    fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
    
    for i := 0; i < 20; i++ {
        slice = append(slice, i)
        fmt.Printf("len: %d, cap: %d\n", len(slice), cap(slice))
    }
    
    // è¾“å‡ºï¼š
    // len: 0, cap: 1
    // len: 1, cap: 1
    // len: 2, cap: 2
    // len: 3, cap: 4
    // len: 4, cap: 4
    // len: 5, cap: 8
    // ...
}
```

### 3. æ‰©å®¹å¯¼è‡´çš„é—®é¢˜

```go
package main

import "fmt"

func main() {
    slice1 := []int{1, 2, 3}
    slice2 := slice1
    
    fmt.Printf("slice1: %p, %v\n", slice1, slice1)
    fmt.Printf("slice2: %p, %v\n", slice2, slice2)
    
    // è¿½åŠ å…ƒç´ ï¼ˆå¯èƒ½è§¦å‘æ‰©å®¹ï¼‰
    slice1 = append(slice1, 4, 5, 6, 7)
    
    fmt.Printf("slice1: %p, %v\n", slice1, slice1)
    fmt.Printf("slice2: %p, %v\n", slice2, slice2)
    
    // æ‰©å®¹åï¼Œslice1 å’Œ slice2 æŒ‡å‘ä¸åŒçš„åº•å±‚æ•°ç»„
    slice1[0] = 100
    fmt.Println("slice1:", slice1)  // [100 2 3 4 5 6 7]
    fmt.Println("slice2:", slice2)  // [1 2 3]
}
```

---

## åˆ‡ç‰‡æ“ä½œ

### 1. åˆ‡ç‰‡æ’å…¥

```go
package main

import "fmt"

func insert(slice []int, index int, value int) []int {
    // åœ¨ç´¢å¼• index å¤„æ’å…¥ value
    slice = append(slice[:index], append([]int{value}, slice[index:]...)...)
    return slice
}

func main() {
    slice := []int{1, 2, 3, 4, 5}
    slice = insert(slice, 2, 100)
    fmt.Println(slice)  // [1 2 100 3 4 5]
}
```

### 2. åˆ‡ç‰‡åˆ é™¤

```go
package main

import "fmt"

// åˆ é™¤ç´¢å¼• i å¤„çš„å…ƒç´ 
func remove(slice []int, i int) []int {
    return append(slice[:i], slice[i+1:]...)
}

// åˆ é™¤ç´¢å¼• i å¤„çš„å…ƒç´ ï¼ˆä¸ä¿æŒé¡ºåºï¼Œæ›´å¿«ï¼‰
func removeFast(slice []int, i int) []int {
    slice[i] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}

func main() {
    slice := []int{1, 2, 3, 4, 5}
    slice = remove(slice, 2)
    fmt.Println(slice)  // [1 2 4 5]
    
    slice = []int{1, 2, 3, 4, 5}
    slice = removeFast(slice, 2)
    fmt.Println(slice)  // [1 2 5 4]
}
```

### 3. åˆ‡ç‰‡è¿‡æ»¤

```go
package main

import "fmt"

func filter(slice []int, fn func(int) bool) []int {
    result := slice[:0]  // å¤ç”¨åº•å±‚æ•°ç»„
    for _, v := range slice {
        if fn(v) {
            result = append(result, v)
        }
    }
    return result
}

func main() {
    slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    // è¿‡æ»¤å¶æ•°
    evens := filter(slice, func(n int) bool {
        return n%2 == 0
    })
    fmt.Println(evens)  // [2 4 6 8 10]
}
```

### 4. åˆ‡ç‰‡å»é‡

```go
package main

import "fmt"

func unique(slice []int) []int {
    seen := make(map[int]bool)
    result := []int{}
    
    for _, v := range slice {
        if !seen[v] {
            seen[v] = true
            result = append(result, v)
        }
    }
    
    return result
}

func main() {
    slice := []int{1, 2, 2, 3, 3, 3, 4, 5, 5}
    result := unique(slice)
    fmt.Println(result)  // [1 2 3 4 5]
}
```

### 5. åˆ‡ç‰‡åè½¬

```go
package main

import "fmt"

func reverse(slice []int) {
    for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
        slice[i], slice[j] = slice[j], slice[i]
    }
}

func main() {
    slice := []int{1, 2, 3, 4, 5}
    reverse(slice)
    fmt.Println(slice)  // [5 4 3 2 1]
}
```

---

## ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹ 1: åˆ‡ç‰‡ä½œä¸ºæ ˆ

```go
package main

import "fmt"

type Stack struct {
    data []int
}

func (s *Stack) Push(v int) {
    s.data = append(s.data, v)
}

func (s *Stack) Pop() (int, bool) {
    if len(s.data) == 0 {
        return 0, false
    }
    v := s.data[len(s.data)-1]
    s.data = s.data[:len(s.data)-1]
    return v, true
}

func (s *Stack) Peek() (int, bool) {
    if len(s.data) == 0 {
        return 0, false
    }
    return s.data[len(s.data)-1], true
}

func (s *Stack) IsEmpty() bool {
    return len(s.data) == 0
}

func main() {
    stack := &Stack{}
    
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    
    fmt.Println(stack.Pop())   // 3 true
    fmt.Println(stack.Peek())  // 2 true
    fmt.Println(stack.Pop())   // 2 true
    fmt.Println(stack.Pop())   // 1 true
    fmt.Println(stack.Pop())   // 0 false
}
```

### ç¤ºä¾‹ 2: åˆ‡ç‰‡ä½œä¸ºé˜Ÿåˆ—

```go
package main

import "fmt"

type Queue struct {
    data []int
}

func (q *Queue) Enqueue(v int) {
    q.data = append(q.data, v)
}

func (q *Queue) Dequeue() (int, bool) {
    if len(q.data) == 0 {
        return 0, false
    }
    v := q.data[0]
    q.data = q.data[1:]
    return v, true
}

func (q *Queue) IsEmpty() bool {
    return len(q.data) == 0
}

func main() {
    queue := &Queue{}
    
    queue.Enqueue(1)
    queue.Enqueue(2)
    queue.Enqueue(3)
    
    fmt.Println(queue.Dequeue())  // 1 true
    fmt.Println(queue.Dequeue())  // 2 true
    fmt.Println(queue.Dequeue())  // 3 true
    fmt.Println(queue.Dequeue())  // 0 false
}
```

### ç¤ºä¾‹ 3: æ»‘åŠ¨çª—å£

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k == 0 {
        return []int{}
    }
    
    result := make([]int, 0, len(nums)-k+1)
    
    for i := 0; i <= len(nums)-k; i++ {
        max := nums[i]
        for j := i; j < i+k; j++ {
            if nums[j] > max {
                max = nums[j]
            }
        }
        result = append(result, max)
    }
    
    return result
}

func main() {
    nums := []int{1, 3, -1, -3, 5, 3, 6, 7}
    k := 3
    result := maxSlidingWindow(nums, k)
    fmt.Println(result)  // [3 3 5 5 6 7]
}
```

---

## å¸¸è§é—®é¢˜

### 1. æ•°ç»„å’Œåˆ‡ç‰‡çš„åŒºåˆ«ï¼Ÿ

| ç‰¹æ€§ | æ•°ç»„ | åˆ‡ç‰‡ |
|------|------|------|
| é•¿åº¦ | å›ºå®š | åŠ¨æ€ |
| ç±»å‹ | å€¼ç±»å‹ | å¼•ç”¨ç±»å‹ |
| ä¼ é€’ | å¤åˆ¶æ•´ä¸ªæ•°ç»„ | å¤åˆ¶åˆ‡ç‰‡å¤´ |
| æ¯”è¾ƒ | å¯ä»¥ç”¨ == | ä¸èƒ½ç”¨ == |
| æ€§èƒ½ | æ›´å¥½ï¼ˆæ ˆåˆ†é…ï¼‰ | ç¨å·®ï¼ˆå †åˆ†é…ï¼‰ |

### 2. åˆ‡ç‰‡çš„é•¿åº¦å’Œå®¹é‡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

```go
slice := make([]int, 3, 5)
// len(slice) = 3  // å½“å‰å…ƒç´ ä¸ªæ•°
// cap(slice) = 5  // åº•å±‚æ•°ç»„å®¹é‡

// å¯ä»¥è®¿é—® slice[0], slice[1], slice[2]
// ä¸èƒ½è®¿é—® slice[3], slice[4] (ä¼š panic)
```

### 3. ä¸ºä»€ä¹ˆåˆ‡ç‰‡ä¸èƒ½æ¯”è¾ƒï¼Ÿ

```go
// åˆ‡ç‰‡ä¸èƒ½ç”¨ == æ¯”è¾ƒï¼ˆåªèƒ½ä¸ nil æ¯”è¾ƒï¼‰
slice1 := []int{1, 2, 3}
slice2 := []int{1, 2, 3}
// fmt.Println(slice1 == slice2)  // ç¼–è¯‘é”™è¯¯

// åŸå› ï¼š
// 1. åˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œæ¯”è¾ƒè¯­ä¹‰ä¸æ˜ç¡®
// 2. åˆ‡ç‰‡å¯èƒ½å…±äº«åº•å±‚æ•°ç»„
// 3. æ€§èƒ½è€ƒè™‘

// æ­£ç¡®åšæ³•ï¼šè‡ªå·±å®ç°æ¯”è¾ƒå‡½æ•°
func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

### 4. append ä»€ä¹ˆæ—¶å€™ä¼šè§¦å‘æ‰©å®¹ï¼Ÿ

```go
// å½“ len(slice) == cap(slice) æ—¶ï¼Œappend ä¼šè§¦å‘æ‰©å®¹

slice := make([]int, 3, 5)
fmt.Println(len(slice), cap(slice))  // 3 5

slice = append(slice, 1)  // ä¸æ‰©å®¹
fmt.Println(len(slice), cap(slice))  // 4 5

slice = append(slice, 2)  // ä¸æ‰©å®¹
fmt.Println(len(slice), cap(slice))  // 5 5

slice = append(slice, 3)  // æ‰©å®¹ï¼
fmt.Println(len(slice), cap(slice))  // 6 10
```

---

## é¢è¯•é¢˜

### 1. ä¸‹é¢ä»£ç è¾“å‡ºä»€ä¹ˆï¼Ÿ

```go
func main() {
    slice := []int{1, 2, 3, 4, 5}
    newSlice := slice[1:3]
    newSlice[0] = 100
    fmt.Println(slice)
    fmt.Println(newSlice)
}
```

**ç­”æ¡ˆï¼š**
```
[1 100 3 4 5]
[100 3]
```

**è§£æï¼š** åˆ‡ç‰‡å…±äº«åº•å±‚æ•°ç»„ï¼Œä¿®æ”¹ newSlice ä¼šå½±å“ slice

### 2. ä¸‹é¢ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ

```go
func main() {
    slice := []int{1, 2, 3}
    for _, v := range slice {
        slice = append(slice, v)
    }
    fmt.Println(slice)
}
```

**ç­”æ¡ˆï¼š** æ— é™å¾ªç¯ï¼ˆå®é™…ä¸Šä¸ä¼šï¼Œå› ä¸º range åœ¨å¼€å§‹æ—¶å°±ç¡®å®šäº†è¿­ä»£æ¬¡æ•°ï¼‰

**è¾“å‡ºï¼š** `[1 2 3 1 2 3]`

**è§£æï¼š** range åœ¨å¼€å§‹æ—¶å°±å¤åˆ¶äº†åˆ‡ç‰‡çš„é•¿åº¦ï¼Œæ‰€ä»¥åªä¼šè¿­ä»£ 3 æ¬¡

### 3. å¦‚ä½•æ­£ç¡®åœ°åˆ é™¤åˆ‡ç‰‡ä¸­çš„å…ƒç´ ï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
// æ–¹æ³• 1: ä¿æŒé¡ºåº
slice = append(slice[:i], slice[i+1:]...)

// æ–¹æ³• 2: ä¸ä¿æŒé¡ºåºï¼ˆæ›´å¿«ï¼‰
slice[i] = slice[len(slice)-1]
slice = slice[:len(slice)-1]

// æ–¹æ³• 3: ä½¿ç”¨ copy
copy(slice[i:], slice[i+1:])
slice = slice[:len(slice)-1]
```

### 4. åˆ‡ç‰‡ä½œä¸ºå‡½æ•°å‚æ•°æ—¶ï¼Œä¿®æ”¹ä¼šå½±å“åŸåˆ‡ç‰‡å—ï¼Ÿ

**ç­”æ¡ˆï¼š** åˆ†æƒ…å†µ

```go
// ä¿®æ”¹å…ƒç´ ï¼šä¼šå½±å“
func modify(s []int) {
    s[0] = 100  // âœ… ä¼šå½±å“åŸåˆ‡ç‰‡
}

// appendï¼šä¸ä¼šå½±å“
func appendSlice(s []int) {
    s = append(s, 4)  // âŒ ä¸ä¼šå½±å“åŸåˆ‡ç‰‡
}

// æ­£ç¡®åšæ³•ï¼šè¿”å›æ–°åˆ‡ç‰‡
func appendSlice(s []int) []int {
    return append(s, 4)
}
```

### 5. å¦‚ä½•é«˜æ•ˆåœ°é¢„åˆ†é…åˆ‡ç‰‡ï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
// âŒ ä¸æ¨èï¼ˆå¤šæ¬¡æ‰©å®¹ï¼‰
var slice []int
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}

// âœ… æ¨èï¼ˆé¢„åˆ†é…å®¹é‡ï¼‰
slice := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}

// âœ… æ¨èï¼ˆå·²çŸ¥é•¿åº¦ï¼‰
slice := make([]int, 1000)
for i := 0; i < 1000; i++ {
    slice[i] = i
}
```

---

## æœ€ä½³å®è·µ

### 1. é¢„åˆ†é…åˆ‡ç‰‡å®¹é‡

```go
// âœ… æ¨è
slice := make([]int, 0, 100)

// âŒ ä¸æ¨è
var slice []int
```

### 2. é¿å…åˆ‡ç‰‡å†…å­˜æ³„æ¼

```go
// âŒ å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
func getFirstN(data []byte, n int) []byte {
    return data[:n]  // ä»ç„¶å¼•ç”¨æ•´ä¸ªåº•å±‚æ•°ç»„
}

// âœ… æ¨è
func getFirstN(data []byte, n int) []byte {
    result := make([]byte, n)
    copy(result, data[:n])
    return result
}
```

### 3. ä½¿ç”¨å®Œæ•´åˆ‡ç‰‡è¡¨è¾¾å¼

```go
// âœ… æ¨èï¼ˆé™åˆ¶å®¹é‡ï¼Œé¿å…æ„å¤–ä¿®æ”¹ï¼‰
slice := data[low:high:max]

// âŒ ä¸æ¨è
slice := data[low:high]
```

### 4. åˆ‡ç‰‡ä½œä¸ºå‡½æ•°å‚æ•°

```go
// âœ… æ¨èï¼ˆä¿®æ”¹å…ƒç´ ï¼‰
func modify(s []int) {
    s[0] = 100
}

// âœ… æ¨èï¼ˆappendï¼‰
func appendSlice(s []int) []int {
    return append(s, 4)
}
```

### 5. é¿å…åœ¨å¾ªç¯ä¸­ append

```go
// âŒ ä¸æ¨è
var result []int
for i := 0; i < 1000; i++ {
    result = append(result, i)
}

// âœ… æ¨è
result := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    result = append(result, i)
}
```

---

## å‚è€ƒèµ„æ–™

- [x] [Go å®˜æ–¹æ–‡æ¡£ - Slices](https://go.dev/blog/slices-intro)
- [x] [Go å®˜æ–¹æ–‡æ¡£ - Arrays, slices](https://go.dev/doc/effective_go#arrays)
- [x] [Go Slices: usage and internals](https://go.dev/blog/slices)
- [x] [Go by Example - Arrays](https://gobyexample.com/arrays)
- [x] [Go by Example - Slices](https://gobyexample.com/slices)

---

**ä¸‹ä¸€èŠ‚ï¼š** [07-Map](./07-Map.md)
