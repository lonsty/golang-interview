# 10-é”™è¯¯å¤„ç†

[â† è¿”å›æœ¬ç« ç›®å½•](./README.md) | [â† è¿”å›æ€»ç›®å½•](../README.md)

---

## ğŸ“‹ ç›®å½•

- [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
- [error æ¥å£](#error-æ¥å£)
- [é”™è¯¯åˆ›å»º](#é”™è¯¯åˆ›å»º)
- [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
- [é”™è¯¯åŒ…è£…](#é”™è¯¯åŒ…è£…)
- [panic å’Œ recover](#panic-å’Œ-recover)
- [defer æœºåˆ¶](#defer-æœºåˆ¶)
- [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [é¢è¯•é¢˜](#é¢è¯•é¢˜)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

---

## æ ¸å¿ƒæ¦‚å¿µ

Go è¯­è¨€çš„é”™è¯¯å¤„ç†å“²å­¦ï¼š**æ˜¾å¼é”™è¯¯å¤„ç†**

```
ç‰¹ç‚¹ï¼š
1. error æ˜¯æ¥å£ç±»å‹
2. é”™è¯¯ä½œä¸ºè¿”å›å€¼
3. å¿…é¡»æ˜¾å¼å¤„ç†é”™è¯¯
4. panic ç”¨äºä¸å¯æ¢å¤çš„é”™è¯¯
5. defer ç”¨äºèµ„æºæ¸…ç†
```

### é”™è¯¯å¤„ç†åŸåˆ™

- **åŠæ—¶å¤„ç†**ï¼šä¸è¦å¿½ç•¥é”™è¯¯
- **å‘ä¸Šä¼ é€’**ï¼šæ— æ³•å¤„ç†æ—¶å‘ä¸Šä¼ é€’
- **æ·»åŠ ä¸Šä¸‹æ–‡**ï¼šåŒ…è£…é”™è¯¯æ·»åŠ ä¿¡æ¯
- **åŒºåˆ†ç±»å‹**ï¼šå¯æ¢å¤ vs ä¸å¯æ¢å¤

---

## error æ¥å£

### 1. error æ¥å£å®šä¹‰

```go
// error æ¥å£
type error interface {
    Error() string
}
```

### 2. å®ç° error æ¥å£

```go
package main

import "fmt"

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("é”™è¯¯ç : %d, æ¶ˆæ¯: %s", e.Code, e.Message)
}

func main() {
    err := &MyError{
        Code:    404,
        Message: "èµ„æºæœªæ‰¾åˆ°",
    }
    
    fmt.Println(err.Error())
}
```

---

## é”™è¯¯åˆ›å»º

### 1. errors.New

```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("é™¤æ•°ä¸èƒ½ä¸º0")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    fmt.Println("ç»“æœ:", result)
}
```

### 2. fmt.Errorf

```go
package main

import (
    "fmt"
)

func readFile(filename string) error {
    // æ¨¡æ‹Ÿè¯»å–æ–‡ä»¶å¤±è´¥
    return fmt.Errorf("æ— æ³•è¯»å–æ–‡ä»¶: %s", filename)
}

func main() {
    err := readFile("test.txt")
    if err != nil {
        fmt.Println(err)
    }
}
```

### 3. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```go
package main

import "fmt"

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("å­—æ®µ %s éªŒè¯å¤±è´¥: %s", e.Field, e.Message)
}

func validateAge(age int) error {
    if age < 0 || age > 150 {
        return &ValidationError{
            Field:   "age",
            Message: "å¹´é¾„å¿…é¡»åœ¨ 0-150 ä¹‹é—´",
        }
    }
    return nil
}

func main() {
    err := validateAge(200)
    if err != nil {
        fmt.Println(err)
    }
}
```

### 4. é¢„å®šä¹‰é”™è¯¯

```go
package main

import (
    "errors"
    "fmt"
)

var (
    ErrNotFound     = errors.New("èµ„æºæœªæ‰¾åˆ°")
    ErrUnauthorized = errors.New("æœªæˆæƒ")
    ErrInvalidInput = errors.New("æ— æ•ˆè¾“å…¥")
)

func getUser(id int) error {
    if id <= 0 {
        return ErrInvalidInput
    }
    // æ¨¡æ‹Ÿç”¨æˆ·ä¸å­˜åœ¨
    return ErrNotFound
}

func main() {
    err := getUser(0)
    if err != nil {
        if errors.Is(err, ErrInvalidInput) {
            fmt.Println("è¾“å…¥é”™è¯¯")
        } else if errors.Is(err, ErrNotFound) {
            fmt.Println("ç”¨æˆ·ä¸å­˜åœ¨")
        }
    }
}
```

---

## é”™è¯¯å¤„ç†

### 1. åŸºæœ¬é”™è¯¯å¤„ç†

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // æ–¹å¼ 1: if err != nil
    file, err := os.Open("test.txt")
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    defer file.Close()
    
    // æ–¹å¼ 2: æå‰è¿”å›
    if err := process(); err != nil {
        fmt.Println("å¤„ç†å¤±è´¥:", err)
        return
    }
}

func process() error {
    // ...
    return nil
}
```

### 2. é”™è¯¯ä¼ é€’

```go
package main

import (
    "fmt"
)

func level3() error {
    return fmt.Errorf("level3 é”™è¯¯")
}

func level2() error {
    if err := level3(); err != nil {
        return fmt.Errorf("level2: %w", err)
    }
    return nil
}

func level1() error {
    if err := level2(); err != nil {
        return fmt.Errorf("level1: %w", err)
    }
    return nil
}

func main() {
    if err := level1(); err != nil {
        fmt.Println(err)
        // è¾“å‡º: level1: level2: level3 é”™è¯¯
    }
}
```

### 3. é”™è¯¯ç±»å‹åˆ¤æ–­

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func main() {
    _, err := os.Open("nonexistent.txt")
    
    // æ–¹å¼ 1: ç±»å‹æ–­è¨€
    if pathErr, ok := err.(*os.PathError); ok {
        fmt.Println("è·¯å¾„:", pathErr.Path)
        fmt.Println("æ“ä½œ:", pathErr.Op)
        fmt.Println("é”™è¯¯:", pathErr.Err)
    }
    
    // æ–¹å¼ 2: errors.As
    var pathErr *os.PathError
    if errors.As(err, &pathErr) {
        fmt.Println("è·¯å¾„é”™è¯¯:", pathErr.Path)
    }
}
```

---

## é”™è¯¯åŒ…è£…

### 1. fmt.Errorf with %w

```go
package main

import (
    "errors"
    "fmt"
)

func readConfig() error {
    return errors.New("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨")
}

func initialize() error {
    if err := readConfig(); err != nil {
        return fmt.Errorf("åˆå§‹åŒ–å¤±è´¥: %w", err)
    }
    return nil
}

func main() {
    err := initialize()
    if err != nil {
        fmt.Println(err)
        
        // è§£åŒ…é”™è¯¯
        if errors.Is(err, errors.New("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨")) {
            fmt.Println("é…ç½®æ–‡ä»¶é—®é¢˜")
        }
    }
}
```

### 2. errors.Is

```go
package main

import (
    "errors"
    "fmt"
)

var ErrNotFound = errors.New("æœªæ‰¾åˆ°")

func getUser(id int) error {
    return fmt.Errorf("æŸ¥è¯¢ç”¨æˆ·å¤±è´¥: %w", ErrNotFound)
}

func main() {
    err := getUser(1)
    
    // errors.Is å¯ä»¥åˆ¤æ–­åŒ…è£…åçš„é”™è¯¯
    if errors.Is(err, ErrNotFound) {
        fmt.Println("ç”¨æˆ·ä¸å­˜åœ¨")
    }
}
```

### 3. errors.As

```go
package main

import (
    "errors"
    "fmt"
)

type MyError struct {
    Code int
    Msg  string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("é”™è¯¯ %d: %s", e.Code, e.Msg)
}

func doSomething() error {
    return fmt.Errorf("æ“ä½œå¤±è´¥: %w", &MyError{Code: 500, Msg: "å†…éƒ¨é”™è¯¯"})
}

func main() {
    err := doSomething()
    
    var myErr *MyError
    if errors.As(err, &myErr) {
        fmt.Printf("é”™è¯¯ç : %d, æ¶ˆæ¯: %s\n", myErr.Code, myErr.Msg)
    }
}
```

---

## panic å’Œ recover

### 1. panic

```go
package main

import "fmt"

func main() {
    fmt.Println("å¼€å§‹")
    
    // panic ä¼šç»ˆæ­¢ç¨‹åº
    panic("å‘ç”Ÿäº†ä¸¥é‡é”™è¯¯")
    
    fmt.Println("ç»“æŸ")  // ä¸ä¼šæ‰§è¡Œ
}
```

### 2. recover

```go
package main

import "fmt"

func safeDivide(a, b int) (result int) {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("æ•è·åˆ° panic:", r)
            result = 0
        }
    }()
    
    return a / b
}

func main() {
    result := safeDivide(10, 0)
    fmt.Println("ç»“æœ:", result)
    fmt.Println("ç¨‹åºç»§ç»­è¿è¡Œ")
}
```

### 3. panic ä½¿ç”¨åœºæ™¯

```go
package main

import (
    "fmt"
    "regexp"
)

var (
    // ç¼–è¯‘æ—¶ panicï¼ˆç¨‹åºæ— æ³•ç»§ç»­ï¼‰
    emailRegex = regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}$`)
)

func init() {
    // åˆå§‹åŒ–å¤±è´¥æ—¶ panic
    if emailRegex == nil {
        panic("æ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘å¤±è´¥")
    }
}

func main() {
    fmt.Println("ç¨‹åºå¯åŠ¨")
}
```

---

## defer æœºåˆ¶

### 1. defer åŸºæœ¬ç”¨æ³•

```go
package main

import "fmt"

func main() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    
    fmt.Println("main")
    
    // è¾“å‡ºé¡ºåº:
    // main
    // 3
    // 2
    // 1
}
```

### 2. defer ç”¨äºèµ„æºæ¸…ç†

```go
package main

import (
    "fmt"
    "os"
)

func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // ç¡®ä¿æ–‡ä»¶è¢«å…³é—­
    
    // è¯»å–æ–‡ä»¶...
    
    return nil
}

func main() {
    if err := readFile("test.txt"); err != nil {
        fmt.Println("é”™è¯¯:", err)
    }
}
```

### 3. defer å‚æ•°æ±‚å€¼

```go
package main

import "fmt"

func main() {
    i := 0
    
    // defer æ³¨å†Œæ—¶å‚æ•°å°±å·²ç»æ±‚å€¼
    defer fmt.Println("defer:", i)  // è¾“å‡º: defer: 0
    
    i++
    fmt.Println("main:", i)  // è¾“å‡º: main: 1
}
```

### 4. defer ä¿®æ”¹è¿”å›å€¼

```go
package main

import "fmt"

func test() (result int) {
    defer func() {
        result++
    }()
    return 5
}

func main() {
    fmt.Println(test())  // è¾“å‡º: 6
}
```

---

## ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹ 1: é”™è¯¯å¤„ç†é“¾

```go
package main

import (
    "fmt"
)

type Error struct {
    Op  string
    Err error
}

func (e *Error) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Op, e.Err)
    }
    return e.Op
}

func (e *Error) Unwrap() error {
    return e.Err
}

func readDatabase() error {
    return &Error{Op: "read", Err: fmt.Errorf("è¿æ¥å¤±è´¥")}
}

func getUser() error {
    if err := readDatabase(); err != nil {
        return &Error{Op: "getUser", Err: err}
    }
    return nil
}

func main() {
    if err := getUser(); err != nil {
        fmt.Println(err)
        // è¾“å‡º: getUser: read: è¿æ¥å¤±è´¥
    }
}
```

### ç¤ºä¾‹ 2: é‡è¯•æœºåˆ¶

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

func retry(attempts int, sleep time.Duration, fn func() error) error {
    for i := 0; i < attempts; i++ {
        if err := fn(); err != nil {
            if i == attempts-1 {
                return err
            }
            fmt.Printf("å°è¯• %d å¤±è´¥ï¼Œ%v åé‡è¯•\n", i+1, sleep)
            time.Sleep(sleep)
            continue
        }
        return nil
    }
    return errors.New("é‡è¯•æ¬¡æ•°ç”¨å°½")
}

func unstableOperation() error {
    // æ¨¡æ‹Ÿä¸ç¨³å®šçš„æ“ä½œ
    return errors.New("æ“ä½œå¤±è´¥")
}

func main() {
    err := retry(3, time.Second, unstableOperation)
    if err != nil {
        fmt.Println("æœ€ç»ˆå¤±è´¥:", err)
    }
}
```

### ç¤ºä¾‹ 3: é”™è¯¯èšåˆ

```go
package main

import (
    "fmt"
    "strings"
)

type MultiError struct {
    Errors []error
}

func (m *MultiError) Error() string {
    var msgs []string
    for _, err := range m.Errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

func (m *MultiError) Add(err error) {
    if err != nil {
        m.Errors = append(m.Errors, err)
    }
}

func (m *MultiError) HasErrors() bool {
    return len(m.Errors) > 0
}

func validateUser(name string, age int, email string) error {
    var errs MultiError
    
    if name == "" {
        errs.Add(fmt.Errorf("å§“åä¸èƒ½ä¸ºç©º"))
    }
    
    if age < 0 || age > 150 {
        errs.Add(fmt.Errorf("å¹´é¾„æ— æ•ˆ"))
    }
    
    if !strings.Contains(email, "@") {
        errs.Add(fmt.Errorf("é‚®ç®±æ ¼å¼é”™è¯¯"))
    }
    
    if errs.HasErrors() {
        return &errs
    }
    
    return nil
}

func main() {
    err := validateUser("", 200, "invalid")
    if err != nil {
        fmt.Println("éªŒè¯å¤±è´¥:", err)
    }
}
```

---

## å¸¸è§é—®é¢˜

### 1. error å’Œ panic çš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**

| ç‰¹æ€§ | error | panic |
|------|-------|-------|
| ç”¨é€” | å¯é¢„æœŸçš„é”™è¯¯ | ä¸å¯æ¢å¤çš„é”™è¯¯ |
| å¤„ç†æ–¹å¼ | è¿”å›å€¼ | ä¸­æ–­ç¨‹åº |
| æ¢å¤ | æ­£å¸¸å¤„ç† | recover |
| ä½¿ç”¨åœºæ™¯ | ä¸šåŠ¡é€»è¾‘ | ç¨‹åºbugã€åˆå§‹åŒ–å¤±è´¥ |

### 2. ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ panicï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
// âœ… é€‚åˆä½¿ç”¨ panic
// 1. ç¨‹åºåˆå§‹åŒ–å¤±è´¥
func init() {
    if config == nil {
        panic("é…ç½®åŠ è½½å¤±è´¥")
    }
}

// 2. ä¸å¯èƒ½å‘ç”Ÿçš„æƒ…å†µ
switch value {
case 1, 2, 3:
    // ...
default:
    panic("ä¸å¯èƒ½åˆ°è¾¾è¿™é‡Œ")
}

// 3. ç¼–ç¨‹é”™è¯¯
func divide(a, b int) int {
    if b == 0 {
        panic("é™¤æ•°ä¸èƒ½ä¸º0")  // è°ƒç”¨è€…çš„é”™è¯¯
    }
    return a / b
}

// âŒ ä¸é€‚åˆä½¿ç”¨ panic
// 1. æ­£å¸¸çš„ä¸šåŠ¡é”™è¯¯
func getUser(id int) (*User, error) {
    // return nil, errors.New("ç”¨æˆ·ä¸å­˜åœ¨")  // âœ…
    // panic("ç”¨æˆ·ä¸å­˜åœ¨")  // âŒ
}
```

### 3. defer çš„æ‰§è¡Œé¡ºåºï¼Ÿ

**ç­”æ¡ˆï¼š** LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰

```go
defer fmt.Println("1")  // æœ€åæ‰§è¡Œ
defer fmt.Println("2")  // ç¬¬äºŒæ‰§è¡Œ
defer fmt.Println("3")  // æœ€å…ˆæ‰§è¡Œ
```

### 4. errors.Is å’Œ errors.As çš„åŒºåˆ«ï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
// errors.Is: åˆ¤æ–­é”™è¯¯æ˜¯å¦ç­‰äºæŸä¸ªé”™è¯¯
if errors.Is(err, ErrNotFound) {
    // err æˆ–å…¶åŒ…è£…é“¾ä¸­åŒ…å« ErrNotFound
}

// errors.As: åˆ¤æ–­é”™è¯¯æ˜¯å¦æ˜¯æŸä¸ªç±»å‹
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    // err æˆ–å…¶åŒ…è£…é“¾ä¸­åŒ…å« *os.PathError ç±»å‹
    fmt.Println(pathErr.Path)
}
```

---

## é¢è¯•é¢˜

### 1. ä¸‹é¢ä»£ç è¾“å‡ºä»€ä¹ˆï¼Ÿ

```go
func test() (result int) {
    defer func() {
        result++
    }()
    return 5
}

func main() {
    fmt.Println(test())
}
```

**ç­”æ¡ˆï¼š** 6

**è§£æï¼š** defer å¯ä»¥ä¿®æ”¹å‘½åè¿”å›å€¼

### 2. å¦‚ä½•ä¼˜é›…åœ°å¤„ç†å¤šä¸ªé”™è¯¯ï¼Ÿ

**ç­”æ¡ˆï¼š**

```go
// æ–¹å¼ 1: æå‰è¿”å›
if err := step1(); err != nil {
    return err
}
if err := step2(); err != nil {
    return err
}

// æ–¹å¼ 2: é”™è¯¯èšåˆ
var errs []error
if err := step1(); err != nil {
    errs = append(errs, err)
}
if err := step2(); err != nil {
    errs = append(errs, err)
}
```

### 3. panic å¯ä»¥è·¨ goroutine æ•è·å—ï¼Ÿ

**ç­”æ¡ˆï¼š** ä¸å¯ä»¥

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("æ•è·:", r)
        }
    }()
    
    go func() {
        panic("goroutine panic")  // æ— æ³•è¢«æ•è·
    }()
    
    time.Sleep(time.Second)
}
```

---

## æœ€ä½³å®è·µ

### 1. åŠæ—¶å¤„ç†é”™è¯¯

```go
// âœ… æ¨è
if err := doSomething(); err != nil {
    return err
}

// âŒ ä¸æ¨è
err := doSomething()
// ... å¾ˆå¤šä»£ç 
if err != nil {
    return err
}
```

### 2. æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡

```go
// âœ… æ¨è
if err := readFile(filename); err != nil {
    return fmt.Errorf("è¯»å–é…ç½®æ–‡ä»¶ %s å¤±è´¥: %w", filename, err)
}

// âŒ ä¸æ¨è
if err := readFile(filename); err != nil {
    return err
}
```

### 3. ä½¿ç”¨é¢„å®šä¹‰é”™è¯¯

```go
// âœ… æ¨è
var (
    ErrNotFound = errors.New("æœªæ‰¾åˆ°")
    ErrInvalid  = errors.New("æ— æ•ˆ")
)

func getUser(id int) error {
    return ErrNotFound
}

// âŒ ä¸æ¨è
func getUser(id int) error {
    return errors.New("æœªæ‰¾åˆ°")
}
```

### 4. ä¸è¦å¿½ç•¥é”™è¯¯

```go
// âœ… æ¨è
if err := file.Close(); err != nil {
    log.Printf("å…³é—­æ–‡ä»¶å¤±è´¥: %v", err)
}

// âŒ ä¸æ¨è
file.Close()  // å¿½ç•¥é”™è¯¯
```

### 5. defer ç”¨äºèµ„æºæ¸…ç†

```go
// âœ… æ¨è
file, err := os.Open(filename)
if err != nil {
    return err
}
defer file.Close()

// âŒ ä¸æ¨è
file, err := os.Open(filename)
if err != nil {
    return err
}
// ... å¾ˆå¤šä»£ç 
file.Close()
```

---

## å‚è€ƒèµ„æ–™

- [x] [Go å®˜æ–¹æ–‡æ¡£ - Errors](https://go.dev/blog/error-handling-and-go)
- [x] [Effective Go - Errors](https://go.dev/doc/effective_go#errors)
- [x] [Go by Example - Errors](https://gobyexample.com/errors)
- [x] [Go by Example - Panic](https://gobyexample.com/panic)
- [x] [Go by Example - Defer](https://gobyexample.com/defer)

---

**ä¸‹ä¸€èŠ‚ï¼š** [02-å¹¶å‘ç¼–ç¨‹](../02-å¹¶å‘ç¼–ç¨‹/README.md)
